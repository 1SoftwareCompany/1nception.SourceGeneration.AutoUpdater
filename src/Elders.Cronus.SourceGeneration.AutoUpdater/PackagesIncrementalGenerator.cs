using Microsoft.CodeAnalysis;
using System;
using System.Collections.Generic;
using System.Linq;

namespace Elders.Cronus.SourceGeneration.AutoUpdater;

[Generator(LanguageNames.CSharp)]
public class PackagesIncrementalGenerator : IIncrementalGenerator
{
    private const string Cronus = "cronus";
    private const string CronusGlobalNamespace = "Elders.Cronus";
    private const string CronusBootstrapFileName = "CronusMigratorStartup";
    private const string FileExtension = ".g.cs";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        IncrementalValueProvider<IEnumerable<AssemblyIdentity>> cronusReferencedAssemblyNames = context.CompilationProvider
            .Select(static (c, _) =>
            c.ReferencedAssemblyNames.Where(reference => reference.Name.Contains(Cronus, StringComparison.OrdinalIgnoreCase)));

        context.RegisterSourceOutput(cronusReferencedAssemblyNames, (spc, references) =>
        {
            if (references.Select(x => x.Version.Major).Distinct().Count() == 1) // TODO: decide what we do if there are packets with different versions. For now we need all of them to be latest major version to do an update.
            {
                int theCurrentVersion = references.OrderByDescending(x => x.Version.Major).First().Version.Major;

                string bootstrapFile = GetBootstrapFile(CronusBootstrapFileName, CronusGlobalNamespace, theCurrentVersion);
                spc.AddSource(CronusBootstrapFileName + FileExtension, bootstrapFile);
            }
        });
    }

    private string GetBootstrapFile(string className, string @namespace, int majorAssemblyCronusVersion)
    {
        string cronusAutoUpdaterBootstrapFile = @$"// <auto-generated /> 
using Microsoft.Extensions.Options;
using Microsoft.Extensions.Logging;
using Elders.Cronus.Multitenancy;
using Elders.Cronus.EventStore.AutoUpdater.Commands;
using Elders.Cronus.EventStore.AutoUpdater;
using System;
{(@namespace is null ? null : $@"namespace {@namespace}
{{")}
   [CronusStartup(Bootstraps.Runtime)]
   partial class {className} : ICronusStartup
   {{
      private readonly IPublisher<ICommand> _publisher;
      private readonly BoundedContext _boundedContext;     
      private TenantsOptions _tenantOptions;
      private readonly ILogger<{className}> _logger;
      
      private const int CronusCurrentInstalledVersion = {majorAssemblyCronusVersion};
      
     public {className}(IPublisher<ICommand> publisher, IOptions<BoundedContext> bcProvider, IOptionsMonitor<TenantsOptions> tenantsProvider, ILogger<{className}> logger)
     {{
       _publisher = publisher;
       _boundedContext = bcProvider.Value;
       _tenantOptions = tenantsProvider.CurrentValue;
       _logger = logger;
       tenantsProvider.OnChange(OnTenantsOptionsChanged);
     }}

     public void Bootstrap()
     {{
        foreach(var tenant in _tenantOptions.Tenants)
        {{
            var id = new AutoUpdaterId(_boundedContext.Name ,tenant);
            var command = new RequestAutoUpdate(id, (uint)CronusCurrentInstalledVersion, _boundedContext.Name, DateTimeOffset.UtcNow);
            _publisher.Publish(command);
        }}
     }}

    private void OnTenantsOptionsChanged(TenantsOptions newOptions)
    {{
        if(_logger.IsEnabled(LogLevel.Debug))
            _logger.LogDebug(""Cronus tenants options re-loaded with {{@options}}"", newOptions);

        _tenantOptions = newOptions;
    }}
   }}
{(@namespace is null ? null : @"}
")}";
        return cronusAutoUpdaterBootstrapFile;
    }
}
